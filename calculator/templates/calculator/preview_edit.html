{% extends "base.html" %}

{% load currency_tags %}
{% block content %}
<div class="container">
  <h2 class="mb-4">Edit Preview</h2>

  <form method="post" action="{% url 'preview_edit' %}">
    {% csrf_token %}
    <input type="hidden" name="mode" id="mode" value="advanced">

    <div id="advancedView">
      {% include "calculator/edit_build_advanced.html" %}
    </div>

    <div class="mt-4 d-flex justify-content-between">
  <a href="{% url 'build_preview' %}" class="btn btn-outline-secondary">Cancel</a>
  <button type="submit" class="btn btn-outline-success">Apply changes</button>
    </div>
  </form>
</div>

<!-- Copy the filtering and validation JS from edit_build.html so the UI behaves identically -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  const cpuSelect = document.getElementById("cpu");
  const gpuSelect = document.getElementById("gpu");
  const ramSelect = document.getElementById("ram");
  const moboSelect = document.getElementById("motherboard");
  const caseSelect = document.getElementById("case");
  const psuSelect = document.getElementById("psu");
  const coolerSelect = document.getElementById("cooler");
  const storageSelect = document.getElementById("storage");

  const cpuClear = document.getElementById("cpuClear");
  const gpuClear = document.getElementById("gpuClear");
  const ramClear = document.getElementById("ramClear");
  const storageClear = document.getElementById("storageClear");
  const psuClear = document.getElementById("psuClear");
  const coolerClear = document.getElementById("coolerClear");
  const moboSocketClear = document.getElementById("moboSocketClear");
  const caseFormClear = document.getElementById("caseFormClear");

  function normalizeDDR(s){ return s ? s.toString().trim().toUpperCase() : ""; }
  function normalizeFF(s){
    if (!s) return "";
    const v = s.toLowerCase().replace(/\s|-/g,"");
    if (v.includes("miniitx")) return "mini-itx";
    if (v.includes("microatx")) return "microatx";
    if (v.includes("atx")) return "atx";
    if (v.includes("tower")) return "tower";
    return v;
  }
  function normalizeIface(s){
    if (!s) return "";
    const v = s.toLowerCase();
    if (v.includes("pcie") || v.includes("nvme")) {
      if (v.includes("gen5")) return "pcie gen5";
      if (v.includes("gen4")) return "pcie gen4";
      return "pcie gen3";
    }
    if (v.includes("sata")) return "sata";
    return v;
  }

  function showTooltip(id,msg){ const el=document.getElementById(id); if(el){ el.textContent=msg; el.style.display="block"; } }
  function hideTooltip(id){ const el=document.getElementById(id); if(el){ el.style.display="none"; el.textContent = ""; } }
  function markInvalid(sel){ sel.classList.add("is-invalid"); sel.setAttribute("aria-invalid","true"); }
  function clearInvalid(sel){ sel.classList.remove("is-invalid"); sel.removeAttribute("aria-invalid"); }
  function setCpuMoboInvalid(invalid, moboMsg, cpuMsg){
    if(invalid){
      if (moboMsg) showTooltip("moboMessage", moboMsg);
      if (cpuMsg) showTooltip("cpuMessage", cpuMsg);
      markInvalid(moboSelect);
      markInvalid(cpuSelect);
    } else {
      clearInvalid(moboSelect);
      clearInvalid(cpuSelect);
      hideTooltip("moboMessage");
      hideTooltip("cpuMessage");
    }
  }
  function ensureSelection(select){
    const sel = select.selectedOptions[0];
    if (!sel || sel.hidden) {
      const firstVisible = [...select.options].find(o => !o.hidden);
      if (firstVisible) firstVisible.selected = true;
    }
  }
  function activate(groupId, btn){
    document.querySelectorAll(`#${groupId} button`).forEach(b=>{
      b.classList.remove("btn-primary");
      b.classList.add("btn-outline-primary");
    });
    btn.classList.remove("btn-outline-primary");
    btn.classList.add("btn-primary");
  }

  function filterMobosByCpu(showTip=false){
    // Do NOT hide motherboard options here. Button toggles handle filtering.
    // Only validate the current selection and surface compatibility warnings.
    const cpuSocket = cpuSelect.selectedOptions[0]?.dataset.socket || "";
    const moboSocket = moboSelect.selectedOptions[0]?.dataset.socket || "";
    const incompatible = !!(cpuSocket && moboSocket && cpuSocket !== moboSocket);
    if (incompatible) {
      setCpuMoboInvalid(true, `CPU socket mismatch. Select a ${cpuSocket} motherboard.`, `Selected CPU socket ${cpuSocket} is not supported by the current motherboard.`);
    } else {
      setCpuMoboInvalid(false);
    }
  }

  function filterMobosByRam(showTip=false){
    // Validate RAM vs selected motherboard DDR. Do not hide options here.
    const ramDDR = normalizeDDR(ramSelect.selectedOptions[0]?.dataset.ddr);
    const moboDDR = normalizeDDR(moboSelect.selectedOptions[0]?.dataset.ddr);
    const incompatible = !!(ramDDR && moboDDR && ramDDR !== moboDDR);
    if (incompatible) {
      showTooltip("ramMessage", `Selected RAM (${ramDDR}) may not be supported by motherboard.`);
      showTooltip("moboMessage", `Motherboard may not support selected RAM (${ramDDR}).`);
      markInvalid(moboSelect);
      markInvalid(ramSelect);
    } else {
      clearInvalid(moboSelect);
      clearInvalid(ramSelect);
      hideTooltip("ramMessage");
      hideTooltip("moboMessage");
    }
  }

  function filterRamByMobo(showTip=false){
    // Validate the currently selected RAM against the motherboard. Do not hide options.
    const moboDDR = normalizeDDR(moboSelect.selectedOptions[0]?.dataset.ddr);
    const ramDDR = normalizeDDR(ramSelect.selectedOptions[0]?.dataset.ddr);
    const incompatible = !!(moboDDR && ramDDR && moboDDR !== ramDDR);
    if (incompatible) {
      showTooltip("moboMessage", `Use ${moboDDR} RAM for this motherboard.`);
      showTooltip("ramMessage", `Selected RAM is not compatible with the motherboard. Use ${moboDDR} RAM.`);
      markInvalid(ramSelect);
      markInvalid(moboSelect);
    } else {
      clearInvalid(ramSelect);
      clearInvalid(moboSelect);
      hideTooltip("moboMessage");
      hideTooltip("ramMessage");
    }
  }

  function filterCases(showTip=false) {
   // Keep filtering via button toggles only. Validate current selection against motherboard
   // but do not hide options programmatically.
   const activeCaseBtn = document.querySelector("#caseFormFilters button.btn-primary");
   const moboFF = normalizeFF(moboSelect.selectedOptions[0]?.dataset.formfactor || "");
   const caseFF = normalizeFF(caseSelect.selectedOptions[0]?.dataset.formfactor || "");
   let ok = true;

   if (moboFF && caseFF) {
     if (moboFF.includes("mini") || moboFF.includes("itx")) {
       ok = true;
     } else if (moboFF.includes("micro")) {
       ok = caseFF.includes("atx") || caseFF.includes("micro") || caseFF.includes("mini");
     } else if (moboFF.includes("atx") || moboFF.includes("tower")) {
       ok = !(caseFF.includes("micro") || caseFF.includes("mini"));
     } else {
       ok = caseFF === moboFF || caseFF.includes(moboFF);
     }
   }

   if (!ok) {
     showTooltip("caseMessage", `This case does not fit ${moboFF?.toUpperCase()} motherboards. Please select a compatible case.`);
     markInvalid(caseSelect);
   } else {
     clearInvalid(caseSelect);
     hideTooltip("caseMessage");
   }
  }

  // Ensure choosing a case re-triggers validation so notifications clear when user selects a valid case
  caseSelect?.addEventListener('change', ()=> { filterCases(true); });

  function filterStorage(showTip=false){
    // Validate selected storage against motherboard NVMe support. Do not hide options.
    const moboNvme = (moboSelect.selectedOptions[0]?.dataset.nvme || "false").toLowerCase();
    const iface = normalizeIface(storageSelect.selectedOptions[0]?.dataset.interface);
    const needsNvme = iface && iface.startsWith("pcie");
    if (needsNvme && moboNvme !== "true") {
      showTooltip("storageMessage", `Motherboard does not support NVMe/PCIe. Choose SATA or change motherboard.`);
      markInvalid(storageSelect);
    } else {
      clearInvalid(storageSelect);
      hideTooltip("storageMessage");
    }
  }

  function filterPSUs(showTip=false){
    // Validate current PSU selection against estimated required wattage. Do not hide options.
    const cpuTDP = parseInt(cpuSelect.selectedOptions[0]?.dataset.tdp || "0",10);
    const gpuTDP = parseInt(gpuSelect.selectedOptions[0]?.dataset.tdp || "0",10);
    const required = Math.round((cpuTDP + gpuTDP) * 1.3);
    const selectedW = parseInt(psuSelect.selectedOptions[0]?.dataset.wattage || "0",10);
    if (selectedW && selectedW < required) {
      showTooltip("psuMessage", `PSU insufficient. Select â‰¥ ${required}W.`);
      markInvalid(psuSelect);
    } else {
      clearInvalid(psuSelect);
      hideTooltip("psuMessage");
    }
  }

  function filterCoolers(showTip=false){
    // Validate selected cooler against CPU TDP. Do not hide options.
    const cpuTDP = parseInt(cpuSelect.selectedOptions[0]?.dataset.tdp || "0",10);
    const th = parseInt(coolerSelect.selectedOptions[0]?.dataset.throughput || "0",10);
    if (th && th < cpuTDP) {
      showTooltip("coolerMessage", `Cooler insufficient for CPU TDP (${cpuTDP}W).`);
      markInvalid(coolerSelect);
    } else {
      clearInvalid(coolerSelect);
      hideTooltip("coolerMessage");
    }
  }

  function clearFilter(groupId, select){
    document.querySelectorAll(`#${groupId} button`).forEach(b=>{
      b.classList.remove("btn-primary"); b.classList.add("btn-outline-primary");
    });
    [...select.options].forEach(opt => { opt.hidden = false; });
    ensureSelection(select);
  }

  document.querySelectorAll("#cpuBrandFilters button[data-brand]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const brand = btn.dataset.brand;
      [...cpuSelect.options].forEach(opt => { opt.hidden = (opt.dataset.brand !== brand); });
      activate("cpuBrandFilters", btn);
      ensureSelection(cpuSelect);
      filterMobosByCpu(true);
    });
  });
  cpuClear?.addEventListener("click", ()=> { clearFilter("cpuBrandFilters", cpuSelect); filterMobosByCpu(true); });

  document.querySelectorAll("#gpuBrandFilters button[data-brand]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const brand = btn.dataset.brand;
      [...gpuSelect.options].forEach(opt => { opt.hidden = (opt.dataset.brand !== brand); });
      activate("gpuBrandFilters", btn);
      ensureSelection(gpuSelect);
      filterPSUs(true);
    });
  });
  gpuClear?.addEventListener("click", ()=> clearFilter("gpuBrandFilters", gpuSelect));

  document.querySelectorAll("#ramDDRFilters button[data-ddr]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const ddr = btn.dataset.ddr;
      [...ramSelect.options].forEach(opt => { opt.hidden = normalizeDDR(opt.dataset.ddr) !== ddr; });
      activate("ramDDRFilters", btn);
      ensureSelection(ramSelect);
      filterMobosByRam(true);
      filterRamByMobo(true);
    });
  });
  ramClear?.addEventListener("click", ()=> clearFilter("ramDDRFilters", ramSelect));

  document.querySelectorAll("#storageFilters button[data-iface]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const iface = btn.dataset.iface.toLowerCase();
      [...storageSelect.options].forEach(opt => {
        const norm = normalizeIface(opt.dataset.interface);
        opt.hidden = !norm.includes(iface);
      });
      activate("storageFilters", btn);
      ensureSelection(storageSelect);
      filterStorage(true);
    });
  });
  storageClear?.addEventListener("click", ()=> clearFilter("storageFilters", storageSelect));

  document.querySelectorAll("#psuFilters button[data-wattage]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const minW = parseInt(btn.dataset.wattage,10);
      [...psuSelect.options].forEach(opt => {
        const w = parseInt(opt.dataset.wattage || "0",10);
        opt.hidden = w < minW;
      });
      activate("psuFilters", btn);
      ensureSelection(psuSelect);
      filterPSUs(true);
    });
  });
  psuClear?.addEventListener("click", ()=> clearFilter("psuFilters", psuSelect));

  document.querySelectorAll("#moboSocketFilters button[data-socket]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const socket = btn.dataset.socket;
      [...moboSelect.options].forEach(opt => { opt.hidden = (opt.dataset.socket !== socket); });
      activate("moboSocketFilters", btn);
      ensureSelection(moboSelect);
      filterRamByMobo(true);
      filterCases(true);
      filterStorage(true);
      filterMobosByCpu(true);
    });
  });
  moboSocketClear?.addEventListener("click", ()=> { clearFilter("moboSocketFilters", moboSelect); filterMobosByCpu(true); });

  document.querySelectorAll("#caseFormFilters button[data-formfactor]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const ff = normalizeFF(btn.dataset.formfactor || "");
      [...caseSelect.options].forEach(opt => {
        const caseFF = normalizeFF(opt.dataset.formfactor || "");
        // Prefilter out unknowns
        if (!caseFF) { opt.hidden = true; return; }

        if (ff.includes("micro")) {
          opt.hidden = !caseFF.includes("micro");
        } else if (ff.includes("mini") || ff.includes("itx")) {
          opt.hidden = !(caseFF.includes("itx") || caseFF.includes("mini"));
        } else if (ff.includes("atx") || ff.includes("tower")) {
          // Show ATX/tower cases but exclude mini/micro
          opt.hidden = !((caseFF.includes("atx") || caseFF.includes("tower")) && !caseFF.includes("micro") && !caseFF.includes("mini"));
        } else {
          opt.hidden = !caseFF.includes(ff);
        }
      });
      activate("caseFormFilters", btn);
      ensureSelection(caseSelect);
      filterCases(true);
    });
  });
  caseFormClear?.addEventListener("click", ()=> clearFilter("caseFormFilters", caseSelect));

  document.querySelectorAll("#coolerFilters button[data-throughput]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const minT = parseInt(btn.dataset.throughput,10);
      [...coolerSelect.options].forEach(opt => {
        const th = parseInt(opt.dataset.throughput || "0",10);
        opt.hidden = th < minT;
      });
      activate("coolerFilters", btn);
      ensureSelection(coolerSelect);
      filterCoolers(true);
    });
  });
  coolerClear?.addEventListener("click", ()=> clearFilter("coolerFilters", coolerSelect));

  // Initial pass: run filters but only show tooltips if current selection is invalid
  filterMobosByCpu(true);
  filterMobosByRam(true);
  filterRamByMobo(true);
  filterCases(true);
  filterStorage(true);
  filterPSUs(true);
  filterCoolers(true);

  // Change events to re-check compatibility and tooltips
  cpuSelect.addEventListener("change", ()=>{ filterMobosByCpu(true); filterPSUs(true); filterCoolers(true); });
  gpuSelect.addEventListener("change", ()=>{ filterPSUs(true); });
  ramSelect.addEventListener("change", ()=>{ filterMobosByRam(true); filterRamByMobo(true); });
  moboSelect.addEventListener("change", ()=>{ filterRamByMobo(true); filterCases(true); filterStorage(true); filterMobosByCpu(true); });

});
</script>

{% endblock %}
