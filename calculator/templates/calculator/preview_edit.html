{% extends "base.html" %}

{% load currency_tags %}
{% block content %}
<div class="container">
  <h2 class="mb-4">Edit Preview</h2>

  <form method="post" action="{% url 'preview_edit' %}">
    {% csrf_token %}
    <input type="hidden" name="mode" id="mode" value="advanced">

    <div id="advancedView">
      {% include "calculator/edit_build_advanced.html" %}
    </div>

    <div class="mt-4 d-flex justify-content-between">
      <a href="{% url 'build_preview' %}" class="btn btn-secondary">Cancel</a>
      <button type="submit" class="btn btn-success">Apply changes</button>
    </div>
  </form>
</div>

<!-- Copy the filtering and validation JS from edit_build.html so the UI behaves identically -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  const cpuSelect = document.getElementById("cpu");
  const gpuSelect = document.getElementById("gpu");
  const ramSelect = document.getElementById("ram");
  const moboSelect = document.getElementById("motherboard");
  const caseSelect = document.getElementById("case");
  const psuSelect = document.getElementById("psu");
  const coolerSelect = document.getElementById("cooler");
  const storageSelect = document.getElementById("storage");

  const cpuClear = document.getElementById("cpuClear");
  const gpuClear = document.getElementById("gpuClear");
  const ramClear = document.getElementById("ramClear");
  const storageClear = document.getElementById("storageClear");
  const psuClear = document.getElementById("psuClear");
  const coolerClear = document.getElementById("coolerClear");
  const moboSocketClear = document.getElementById("moboSocketClear");
  const caseFormClear = document.getElementById("caseFormClear");

  function normalizeDDR(s){ return s ? s.toString().trim().toUpperCase() : ""; }
  function normalizeFF(s){
    if (!s) return "";
    const v = s.toLowerCase().replace(/\s|-/g,"");
    if (v.includes("miniitx")) return "mini-itx";
    if (v.includes("microatx")) return "microatx";
    if (v.includes("atx")) return "atx";
    if (v.includes("tower")) return "tower";
    return v;
  }
  function normalizeIface(s){
    if (!s) return "";
    const v = s.toLowerCase();
    if (v.includes("pcie") || v.includes("nvme")) {
      if (v.includes("gen5")) return "pcie gen5";
      if (v.includes("gen4")) return "pcie gen4";
      return "pcie gen3";
    }
    if (v.includes("sata")) return "sata";
    return v;
  }

  function showTooltip(id,msg){ const el=document.getElementById(id); if(el){ el.textContent=msg; el.style.display="block"; } }
  function hideTooltip(id){ const el=document.getElementById(id); if(el){ el.style.display="none"; el.textContent = ""; } }
  function markInvalid(sel){ sel.classList.add("is-invalid"); sel.setAttribute("aria-invalid","true"); }
  function clearInvalid(sel){ sel.classList.remove("is-invalid"); sel.removeAttribute("aria-invalid"); }
  function setCpuMoboInvalid(invalid, moboMsg, cpuMsg){
    if(invalid){
      if (moboMsg) showTooltip("moboMessage", moboMsg);
      if (cpuMsg) showTooltip("cpuMessage", cpuMsg);
      markInvalid(moboSelect);
      markInvalid(cpuSelect);
    } else {
      clearInvalid(moboSelect);
      clearInvalid(cpuSelect);
      hideTooltip("moboMessage");
      hideTooltip("cpuMessage");
    }
  }
  function ensureSelection(select){
    const sel = select.selectedOptions[0];
    if (!sel || sel.hidden) {
      const firstVisible = [...select.options].find(o => !o.hidden);
      if (firstVisible) firstVisible.selected = true;
    }
  }
  function activate(groupId, btn){
    document.querySelectorAll(`#${groupId} button`).forEach(b=>{
      b.classList.remove("btn-primary");
      b.classList.add("btn-outline-primary");
    });
    btn.classList.remove("btn-outline-primary");
    btn.classList.add("btn-primary");
  }

  function filterMobosByCpu(showTip=false){
    const cpuSocket = cpuSelect.selectedOptions[0]?.dataset.socket || "";
    [...moboSelect.options].forEach(opt => { opt.hidden = (opt.dataset.socket !== cpuSocket); });
    const selHidden = moboSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      if (showTip) {
        setCpuMoboInvalid(true, `CPU socket mismatch. Select a ${cpuSocket} motherboard.`, `Selected CPU socket ${cpuSocket} is not supported by the current motherboard.`);
      } else {
        markInvalid(moboSelect);
        markInvalid(cpuSelect);
      }
    } else {
      setCpuMoboInvalid(false);
    }
  }

  function filterMobosByRam(showTip=false){
    const ramDDR = normalizeDDR(ramSelect.selectedOptions[0]?.dataset.ddr);
    [...moboSelect.options].forEach(opt => {
      const moboDDR = normalizeDDR(opt.dataset.ddr);
      opt.hidden = !(ramDDR === moboDDR || !ramDDR);
    });
    const selHidden = moboSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      // Mark both RAM and motherboard as needing attention and show messages
      showTooltip("ramMessage", `Selected RAM (${ramDDR}) may not be supported by motherboard.`);
      showTooltip("moboMessage", `Motherboard may not support selected RAM (${ramDDR}).`);
      markInvalid(moboSelect);
      markInvalid(ramSelect);
    } else {
      // Compatible: clear both tooltips and invalid outlines
      clearInvalid(moboSelect);
      clearInvalid(ramSelect);
      hideTooltip("ramMessage");
      hideTooltip("moboMessage");
    }
  }

  function filterRamByMobo(showTip=false){
    const moboDDR = normalizeDDR(moboSelect.selectedOptions[0]?.dataset.ddr);
    [...ramSelect.options].forEach(opt => {
      const ramDDR = normalizeDDR(opt.dataset.ddr);
      opt.hidden = !(ramDDR === moboDDR || !moboDDR);
    });
    const selHidden = ramSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      // Mark both RAM and motherboard as needing attention
      showTooltip("moboMessage", `Use ${moboDDR} RAM for this motherboard.`);
      showTooltip("ramMessage", `Selected RAM is not compatible with the motherboard. Use ${moboDDR} RAM.`);
      markInvalid(ramSelect);
      markInvalid(moboSelect);
    } else {
      clearInvalid(ramSelect);
      clearInvalid(moboSelect);
      hideTooltip("moboMessage");
      hideTooltip("ramMessage");
    }
  }

  function filterCases(showTip=false) {
   // If a case-size filter button is active, it should override motherboard rules
   const activeCaseBtn = document.querySelector("#caseFormFilters button.btn-primary");
   if (activeCaseBtn) {
     const ff = normalizeFF(activeCaseBtn.dataset.formfactor || "");
     [...caseSelect.options].forEach(opt => {
       const caseFF = normalizeFF(opt.dataset.formfactor || "");
       // Prefilter out options with no form-factor information
       if (!caseFF) { opt.hidden = true; return; }

       if (ff.includes("micro")) {
         opt.hidden = !caseFF.includes("micro");
       } else if (ff.includes("mini") || ff.includes("itx")) {
         opt.hidden = !(caseFF.includes("itx") || caseFF.includes("mini"));
       } else if (ff.includes("atx") || ff.includes("tower")) {
         opt.hidden = !((caseFF.includes("atx") || caseFF.includes("tower")) && !caseFF.includes("micro") && !caseFF.includes("mini"));
       } else {
         opt.hidden = !caseFF.includes(ff);
       }
     });
   } else {
     // Normalize both motherboard and case form-factor strings for robust matching
     const moboFF = normalizeFF(moboSelect.selectedOptions[0]?.dataset.formfactor || "");
     [...caseSelect.options].forEach(opt => {
       const caseFF = normalizeFF(opt.dataset.formfactor || "");
       // Prefilter out options with no form-factor information
       if (!caseFF) { opt.hidden = true; return; }

       let ok = false;
       if (moboFF.includes("mini") || moboFF.includes("itx")) {
         // Mini-ITX mobos fit only in ITX-capable cases
         ok = caseFF.includes("itx") || caseFF.includes("mini");
       } else if (moboFF.includes("micro")) {
         // Micro-ATX mobos require microatx cases
         ok = caseFF.includes("micro");
       } else if (moboFF.includes("atx") || moboFF.includes("tower")) {
         // ATX mobos should exclude tiny/itx-only cases but accept ATX/tower
         ok = (caseFF.includes("atx") || caseFF.includes("tower")) && !caseFF.includes("micro") && !caseFF.includes("mini");
       } else {
         // Fallback strict match
         ok = caseFF === moboFF || caseFF.includes(moboFF);
       }

       opt.hidden = !ok;
     });
   }

   const selHidden = caseSelect.selectedOptions[0]?.hidden;
   if (showTip && selHidden) {
     // If activeCaseBtn present, show message about filter; otherwise show mobo compatibility message
     if (activeCaseBtn) {
       const ffMsg = normalizeFF(activeCaseBtn.dataset.formfactor || "").toUpperCase();
       showTooltip("caseMessage", `Filtered to ${ffMsg} cases; current selection is not of that size.`);
     } else {
       const moboMsg = normalizeFF(moboSelect.selectedOptions[0]?.dataset.formfactor || "").toUpperCase();
       showTooltip("caseMessage", `This case does not fit ${moboMsg} motherboards. Please select a compatible case.`);
     }
     markInvalid(caseSelect);
   }
   if (!selHidden) {
     clearInvalid(caseSelect);
     hideTooltip("caseMessage");
   }
  }

  // Ensure choosing a case re-triggers validation so notifications clear when user selects a valid case
  caseSelect?.addEventListener('change', ()=> { filterCases(true); });

  function filterStorage(showTip=false){
    const moboNvme = (moboSelect.selectedOptions[0]?.dataset.nvme || "false").toLowerCase();
    [...storageSelect.options].forEach(opt => {
      const iface = normalizeIface(opt.dataset.interface);
      let ok = true;
      if (iface.startsWith("pcie")) ok = moboNvme === "true";
      opt.hidden = !ok;
    });
    const selHidden = storageSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      showTooltip("storageMessage", `Motherboard does not support NVMe/PCIe. Choose SATA or change motherboard.`);
      markInvalid(storageSelect);
    } else {
      clearInvalid(storageSelect);
      hideTooltip("storageMessage");
    }
  }

  function filterPSUs(showTip=false){
    const cpuTDP = parseInt(cpuSelect.selectedOptions[0]?.dataset.tdp || "0",10);
    const gpuTDP = parseInt(gpuSelect.selectedOptions[0]?.dataset.tdp || "0",10);
    const required = Math.round((cpuTDP + gpuTDP) * 1.3);
    [...psuSelect.options].forEach(opt => {
      const wattage = parseInt(opt.dataset.wattage || "0",10);
      opt.hidden = wattage < required;
    });
    const selHidden = psuSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      showTooltip("psuMessage", `PSU insufficient. Select ≥ ${required}W.`);
      markInvalid(psuSelect);
    } else {
      clearInvalid(psuSelect);
      hideTooltip("psuMessage");
    }
  }

  function filterCoolers(showTip=false){
    const cpuTDP = parseInt(cpuSelect.selectedOptions[0]?.dataset.tdp || "0",10);
    [...coolerSelect.options].forEach(opt => {
      const th = parseInt(opt.dataset.throughput || "0",10);
      opt.hidden = th < cpuTDP;
    });
    const selHidden = coolerSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      showTooltip("coolerMessage", `Cooler insufficient for CPU TDP (${cpuTDP}W).`);
      markInvalid(coolerSelect);
    } else {
      clearInvalid(coolerSelect);
      hideTooltip("coolerMessage");
    }
  }

  function clearFilter(groupId, select){
    document.querySelectorAll(`#${groupId} button`).forEach(b=>{
      b.classList.remove("btn-primary"); b.classList.add("btn-outline-primary");
    });
    [...select.options].forEach(opt => { opt.hidden = false; });
    ensureSelection(select);
  }

  document.querySelectorAll("#cpuBrandFilters button[data-brand]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const brand = btn.dataset.brand;
      [...cpuSelect.options].forEach(opt => { opt.hidden = (opt.dataset.brand !== brand); });
      activate("cpuBrandFilters", btn);
      showTooltip("cpuMessage", `Filtered CPUs: ${brand.toUpperCase()}.`);
      ensureSelection(cpuSelect);
      filterMobosByCpu(true);
    });
  });
  cpuClear?.addEventListener("click", ()=> { clearFilter("cpuBrandFilters", cpuSelect); filterMobosByCpu(true); });

  document.querySelectorAll("#gpuBrandFilters button[data-brand]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const brand = btn.dataset.brand;
      [...gpuSelect.options].forEach(opt => { opt.hidden = (opt.dataset.brand !== brand); });
      activate("gpuBrandFilters", btn);
      showTooltip("gpuMessage", `Filtered GPUs: ${brand.toUpperCase()}.`);
      ensureSelection(gpuSelect);
      filterPSUs(true);
    });
  });
  gpuClear?.addEventListener("click", ()=> clearFilter("gpuBrandFilters", gpuSelect));

  document.querySelectorAll("#ramDDRFilters button[data-ddr]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const ddr = btn.dataset.ddr;
      [...ramSelect.options].forEach(opt => { opt.hidden = normalizeDDR(opt.dataset.ddr) !== ddr; });
      activate("ramDDRFilters", btn);
      showTooltip("ramMessage", `Filtered RAM: ${ddr}.`);
      ensureSelection(ramSelect);
      filterMobosByRam(true);
      filterRamByMobo(true);
    });
  });
  ramClear?.addEventListener("click", ()=> clearFilter("ramDDRFilters", ramSelect));

  document.querySelectorAll("#storageFilters button[data-iface]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const iface = btn.dataset.iface.toLowerCase();
      [...storageSelect.options].forEach(opt => {
        const norm = normalizeIface(opt.dataset.interface);
        opt.hidden = !norm.includes(iface);
      });
      activate("storageFilters", btn);
      showTooltip("storageMessage", `Filtered Storage: ${iface.toUpperCase()}.`);
      ensureSelection(storageSelect);
      filterStorage(true);
    });
  });
  storageClear?.addEventListener("click", ()=> clearFilter("storageFilters", storageSelect));

  document.querySelectorAll("#psuFilters button[data-wattage]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const minW = parseInt(btn.dataset.wattage,10);
      [...psuSelect.options].forEach(opt => {
        const w = parseInt(opt.dataset.wattage || "0",10);
        opt.hidden = w < minW;
      });
      activate("psuFilters", btn);
      showTooltip("psuMessage", `Filtered PSUs: ≥${minW}W.`);
      ensureSelection(psuSelect);
      filterPSUs(true);
    });
  });
  psuClear?.addEventListener("click", ()=> clearFilter("psuFilters", psuSelect));

  document.querySelectorAll("#moboSocketFilters button[data-socket]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const socket = btn.dataset.socket;
      [...moboSelect.options].forEach(opt => { opt.hidden = (opt.dataset.socket !== socket); });
      activate("moboSocketFilters", btn);
      showTooltip("moboMessage", `Filtered motherboards: ${socket.toUpperCase()}.`);
      ensureSelection(moboSelect);
      filterRamByMobo(true);
      filterCases(true);
      filterStorage(true);
      filterMobosByCpu(true);
    });
  });
  moboSocketClear?.addEventListener("click", ()=> { clearFilter("moboSocketFilters", moboSelect); filterMobosByCpu(true); });

  document.querySelectorAll("#caseFormFilters button[data-formfactor]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const ff = normalizeFF(btn.dataset.formfactor || "");
      [...caseSelect.options].forEach(opt => {
        const caseFF = normalizeFF(opt.dataset.formfactor || "");
        // Prefilter out unknowns
        if (!caseFF) { opt.hidden = true; return; }

        if (ff.includes("micro")) {
          opt.hidden = !caseFF.includes("micro");
        } else if (ff.includes("mini") || ff.includes("itx")) {
          opt.hidden = !(caseFF.includes("itx") || caseFF.includes("mini"));
        } else if (ff.includes("atx") || ff.includes("tower")) {
          // Show ATX/tower cases but exclude mini/micro
          opt.hidden = !((caseFF.includes("atx") || caseFF.includes("tower")) && !caseFF.includes("micro") && !caseFF.includes("mini"));
        } else {
          opt.hidden = !caseFF.includes(ff);
        }
      });
      activate("caseFormFilters", btn);
      showTooltip("caseMessage", `Filtered cases: ${ff.toUpperCase()}.`);
      ensureSelection(caseSelect);
      filterCases(true);
    });
  });
  caseFormClear?.addEventListener("click", ()=> clearFilter("caseFormFilters", caseSelect));

  document.querySelectorAll("#coolerFilters button[data-throughput]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const minT = parseInt(btn.dataset.throughput,10);
      [...coolerSelect.options].forEach(opt => {
        const th = parseInt(opt.dataset.throughput || "0",10);
        opt.hidden = th < minT;
      });
      activate("coolerFilters", btn);
      showTooltip("coolerMessage", `Filtered Coolers: ≥${minT}W.`);
      ensureSelection(coolerSelect);
      filterCoolers(true);
    });
  });
  coolerClear?.addEventListener("click", ()=> clearFilter("coolerFilters", coolerSelect));

  // Initial pass: run filters but only show tooltips if current selection is invalid
  filterMobosByCpu(true);
  filterMobosByRam(true);
  filterRamByMobo(true);
  filterCases(true);
  filterStorage(true);
  filterPSUs(true);
  filterCoolers(true);

  // Change events to re-check compatibility and tooltips
  cpuSelect.addEventListener("change", ()=>{ filterMobosByCpu(true); filterPSUs(true); filterCoolers(true); });
  gpuSelect.addEventListener("change", ()=>{ filterPSUs(true); });
  ramSelect.addEventListener("change", ()=>{ filterMobosByRam(true); filterRamByMobo(true); });
  moboSelect.addEventListener("change", ()=>{ filterRamByMobo(true); filterCases(true); filterStorage(true); filterMobosByCpu(true); });

});
</script>

{% endblock %}
