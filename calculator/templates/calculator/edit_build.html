{% extends "base.html" %}

{% block content %}
<div class="container">
  <h2 class="mb-4">Edit Build #{{ build.pk }}</h2>

  <!-- Toggle buttons -->
  <div class="btn-group mb-4" role="group">
    <button type="button" class="btn btn-primary" id="basicBtn">Basic</button>
    <button type="button" class="btn btn-outline-secondary" id="advancedBtn">Advanced</button>
  </div>

  <form method="post" action="{% url 'edit_build' build.pk %}">
    {% csrf_token %}
    <input type="hidden" name="mode" id="mode" value="basic">

    <!-- BASIC VIEW -->
    <div id="basicView">
      <div class="mb-3">
        <label for="budget" class="form-label">Budget (£)</label>
        <input type="number" name="budget" id="budget" class="form-control"
               value="{{ build.budget|default:1000 }}" required>
        <small class="text-muted">Adjust your budget and parts will be reassigned automatically.</small>
      </div>
      <div class="mt-3 d-flex justify-content-end">
        <button type="submit" class="btn btn-success">Save Changes</button>
      </div>
    </div>

    <!-- ADVANCED VIEW -->
    <div id="advancedView" style="display:none;">

      {% include "calculator/edit_build_advanced.html" %}
    </div>

    <div class="mt-4 d-flex justify-content-between">
      <a href="{% url 'saved_builds' %}" class="btn btn-secondary">Cancel</a>
      <button type="submit" class="btn btn-success">Save Changes</button>
    </div>
  </form>
</div>

<!-- Toggle script -->
<script>
document.addEventListener("DOMContentLoaded", () => {
  const basicBtn = document.getElementById("basicBtn");
  const advancedBtn = document.getElementById("advancedBtn");
  const basicView = document.getElementById("basicView");
  const advancedView = document.getElementById("advancedView");
  const modeField = document.getElementById("mode");

  basicBtn.addEventListener("click", () => {
    basicView.style.display = "block";
    advancedView.style.display = "none";
    modeField.value = "basic";
    basicBtn.classList.add("btn-primary");
    basicBtn.classList.remove("btn-outline-secondary");
    advancedBtn.classList.add("btn-outline-secondary");
    advancedBtn.classList.remove("btn-primary");
  });

  advancedBtn.addEventListener("click", () => {
    basicView.style.display = "none";
    advancedView.style.display = "block";
    modeField.value = "advanced";
    advancedBtn.classList.add("btn-primary");
    advancedBtn.classList.remove("btn-outline-secondary");
    basicBtn.classList.add("btn-outline-secondary");
    basicBtn.classList.remove("btn-primary");
  });
});
</script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const cpuSelect = document.getElementById("cpu");
  const gpuSelect = document.getElementById("gpu");
  const ramSelect = document.getElementById("ram");
  const moboSelect = document.getElementById("motherboard");
  const caseSelect = document.getElementById("case");
  const psuSelect = document.getElementById("psu");
  const coolerSelect = document.getElementById("cooler");
  const storageSelect = document.getElementById("storage");

  const cpuClear = document.getElementById("cpuClear");
  const gpuClear = document.getElementById("gpuClear");
  const ramClear = document.getElementById("ramClear");
  const storageClear = document.getElementById("storageClear");
  const psuClear = document.getElementById("psuClear");
  const coolerClear = document.getElementById("coolerClear");
  const moboSocketClear = document.getElementById("moboSocketClear");
  const caseFormClear = document.getElementById("caseFormClear");

  function normalizeDDR(s){ return s ? s.toString().trim().toUpperCase() : ""; }
  function normalizeFF(s){
    if (!s) return "";
    const v = s.toLowerCase().replace(/\s|-/g,"");
    if (v.includes("miniitx")) return "mini-itx";
    if (v.includes("microatx")) return "microatx";
    if (v.includes("atx")) return "atx";
    if (v.includes("tower")) return "tower";
    return v;
  }
  function normalizeIface(s){
    if (!s) return "";
    const v = s.toLowerCase();
    if (v.includes("pcie") || v.includes("nvme")) {
      if (v.includes("gen5")) return "pcie gen5";
      if (v.includes("gen4")) return "pcie gen4";
      return "pcie gen3";
    }
    if (v.includes("sata")) return "sata";
    return v;
  }

  function showTooltip(id,msg){ const el=document.getElementById(id); if(el){ el.textContent=msg; el.style.display="block"; } }
  function hideTooltip(id){ const el=document.getElementById(id); if(el){ el.style.display="none"; el.textContent = ""; } }
  function markInvalid(sel){ sel.classList.add("is-invalid"); sel.setAttribute("aria-invalid","true"); }
  function clearInvalid(sel){ sel.classList.remove("is-invalid"); sel.removeAttribute("aria-invalid"); }
  // Central helper to set/clear invalid state for CPU and motherboard together
  function setCpuMoboInvalid(invalid, moboMsg, cpuMsg){
    if(invalid){
      if (moboMsg) showTooltip("moboMessage", moboMsg);
      if (cpuMsg) showTooltip("cpuMessage", cpuMsg);
      markInvalid(moboSelect);
      markInvalid(cpuSelect);
    } else {
      clearInvalid(moboSelect);
      clearInvalid(cpuSelect);
      hideTooltip("moboMessage");
      hideTooltip("cpuMessage");
    }
  }
  function ensureSelection(select){
    const sel = select.selectedOptions[0];
    if (!sel || sel.hidden) {
      const firstVisible = [...select.options].find(o => !o.hidden);
      if (firstVisible) firstVisible.selected = true;
    }
  }
  function activate(groupId, btn){
    document.querySelectorAll(`#${groupId} button`).forEach(b=>{
      b.classList.remove("btn-primary");
      b.classList.add("btn-outline-primary");
    });
    btn.classList.remove("btn-outline-primary");
    btn.classList.add("btn-primary");
  }

  function filterMobosByCpu(showTip=false){
    const cpuSocket = cpuSelect.selectedOptions[0]?.dataset.socket || "";
    [...moboSelect.options].forEach(opt => { opt.hidden = (opt.dataset.socket !== cpuSocket); });
    const selHidden = moboSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      if (showTip) {
        setCpuMoboInvalid(true, `CPU socket mismatch. Select a ${cpuSocket} motherboard.`, `Selected CPU socket ${cpuSocket} is not supported by the current motherboard.`);
      } else {
        // mark invalid visually but don't necessarily show tooltips
        markInvalid(moboSelect);
        markInvalid(cpuSelect);
      }
    } else {
      // clear invalid state for both when compatible
      setCpuMoboInvalid(false);
    }
  }

  function filterMobosByRam(showTip=false){
    const ramDDR = normalizeDDR(ramSelect.selectedOptions[0]?.dataset.ddr);
    [...moboSelect.options].forEach(opt => {
      const moboDDR = normalizeDDR(opt.dataset.ddr);
      opt.hidden = !(ramDDR === moboDDR || !ramDDR);
    });
    const selHidden = moboSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      showTooltip("ramMessage", `Motherboard does not support ${ramDDR}. Change motherboard or RAM.`);
      markInvalid(moboSelect);
    } else {
      clearInvalid(moboSelect);
      hideTooltip("ramMessage");
    }
  }

  function filterRamByMobo(showTip=false){
    const moboDDR = normalizeDDR(moboSelect.selectedOptions[0]?.dataset.ddr);
    [...ramSelect.options].forEach(opt => {
      const ramDDR = normalizeDDR(opt.dataset.ddr);
      opt.hidden = !(ramDDR === moboDDR || !moboDDR);
    });
    const selHidden = ramSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      showTooltip("moboMessage", `Use ${moboDDR} RAM for this motherboard.`);
      markInvalid(ramSelect);
    } else {
      clearInvalid(ramSelect);
      hideTooltip("moboMessage");
    }
  }

 function filterCases(showTip=false) {
  const moboFF = (moboSelect.selectedOptions[0]?.dataset.formfactor || "").toLowerCase();
  [...caseSelect.options].forEach(opt => {
    const caseFF = (opt.dataset.formfactor || "").toLowerCase();
    let ok = false;

    if (moboFF.includes("mini")) {
      // Mini-ITX fits in anything
      ok = true;
    } else if (moboFF.includes("micro")) {
      // Micro-ATX not compatible with mini cases
      ok = !caseFF.includes("itx");
    } else if (moboFF.includes("atx")) {
      // ATX not compatible with mini or micro cases
      ok = !(caseFF.includes("mini") || caseFF.includes("micro"));
    } else {
      // Fallback strict match
      ok = caseFF === moboFF;
    }

    opt.hidden = !ok;
  });
  const selHidden = caseSelect.selectedOptions[0]?.hidden;
  if (showTip && selHidden) {
    showTooltip("caseMessage", `This case does not fit ${moboFF.toUpperCase()} motherboards. Please select a compatible case.`);
    markInvalid(caseSelect);
  }
  if (!selHidden) {
    clearInvalid(caseSelect);
    hideTooltip("caseMessage");
  }
}


  function filterStorage(showTip=false){
    const moboNvme = (moboSelect.selectedOptions[0]?.dataset.nvme || "false").toLowerCase();
    [...storageSelect.options].forEach(opt => {
      const iface = normalizeIface(opt.dataset.interface);
      let ok = true;
      if (iface.startsWith("pcie")) ok = moboNvme === "true";
      opt.hidden = !ok;
    });
    const selHidden = storageSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      showTooltip("storageMessage", `Motherboard does not support NVMe/PCIe. Choose SATA or change motherboard.`);
      markInvalid(storageSelect);
    } else {
      clearInvalid(storageSelect);
      hideTooltip("storageMessage");
    }
  }

  function filterPSUs(showTip=false){
    const cpuTDP = parseInt(cpuSelect.selectedOptions[0]?.dataset.tdp || "0",10);
    const gpuTDP = parseInt(gpuSelect.selectedOptions[0]?.dataset.tdp || "0",10);
    const required = Math.round((cpuTDP + gpuTDP) * 1.3);
    [...psuSelect.options].forEach(opt => {
      const wattage = parseInt(opt.dataset.wattage || "0",10);
      opt.hidden = wattage < required;
    });
    const selHidden = psuSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      showTooltip("psuMessage", `PSU insufficient. Select ≥ ${required}W.`);
      markInvalid(psuSelect);
    } else {
      clearInvalid(psuSelect);
      hideTooltip("psuMessage");
    }
  }

  function filterCoolers(showTip=false){
    const cpuTDP = parseInt(cpuSelect.selectedOptions[0]?.dataset.tdp || "0",10);
    [...coolerSelect.options].forEach(opt => {
      const th = parseInt(opt.dataset.throughput || "0",10);
      opt.hidden = th < cpuTDP;
    });
    const selHidden = coolerSelect.selectedOptions[0]?.hidden;
    if (selHidden) {
      showTooltip("coolerMessage", `Cooler insufficient for CPU TDP (${cpuTDP}W).`);
      markInvalid(coolerSelect);
    } else {
      clearInvalid(coolerSelect);
      hideTooltip("coolerMessage");
    }
  }

  // Button filters + highlight
  function clearFilter(groupId, select){
    document.querySelectorAll(`#${groupId} button`).forEach(b=>{
      b.classList.remove("btn-primary"); b.classList.add("btn-outline-primary");
    });
    [...select.options].forEach(opt => { opt.hidden = false; });
    ensureSelection(select);
  }

  document.querySelectorAll("#cpuBrandFilters button[data-brand]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const brand = btn.dataset.brand;
      [...cpuSelect.options].forEach(opt => { opt.hidden = (opt.dataset.brand !== brand); });
      activate("cpuBrandFilters", btn);
      showTooltip("cpuMessage", `Filtered CPUs: ${brand.toUpperCase()}.`);
      ensureSelection(cpuSelect);
      filterMobosByCpu(true);
    });
  });
  cpuClear?.addEventListener("click", ()=> { clearFilter("cpuBrandFilters", cpuSelect); filterMobosByCpu(true); });

  document.querySelectorAll("#gpuBrandFilters button[data-brand]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const brand = btn.dataset.brand;
      [...gpuSelect.options].forEach(opt => { opt.hidden = (opt.dataset.brand !== brand); });
      activate("gpuBrandFilters", btn);
      showTooltip("gpuMessage", `Filtered GPUs: ${brand.toUpperCase()}.`);
      ensureSelection(gpuSelect);
      filterPSUs(true);
    });
  });
  gpuClear?.addEventListener("click", ()=> clearFilter("gpuBrandFilters", gpuSelect));

  document.querySelectorAll("#ramDDRFilters button[data-ddr]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const ddr = btn.dataset.ddr;
      [...ramSelect.options].forEach(opt => { opt.hidden = normalizeDDR(opt.dataset.ddr) !== ddr; });
      activate("ramDDRFilters", btn);
      showTooltip("ramMessage", `Filtered RAM: ${ddr}.`);
      ensureSelection(ramSelect);
      filterMobosByRam(true);
      filterRamByMobo(true);
    });
  });
  ramClear?.addEventListener("click", ()=> clearFilter("ramDDRFilters", ramSelect));

  document.querySelectorAll("#storageFilters button[data-iface]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const iface = btn.dataset.iface.toLowerCase();
      [...storageSelect.options].forEach(opt => {
        const norm = normalizeIface(opt.dataset.interface);
        opt.hidden = !norm.includes(iface);
      });
      activate("storageFilters", btn);
      showTooltip("storageMessage", `Filtered Storage: ${iface.toUpperCase()}.`);
      ensureSelection(storageSelect);
      filterStorage(true);
    });
  });
  storageClear?.addEventListener("click", ()=> clearFilter("storageFilters", storageSelect));

  document.querySelectorAll("#psuFilters button[data-wattage]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const minW = parseInt(btn.dataset.wattage,10);
      [...psuSelect.options].forEach(opt => {
        const w = parseInt(opt.dataset.wattage || "0",10);
        opt.hidden = w < minW;
      });
      activate("psuFilters", btn);
      showTooltip("psuMessage", `Filtered PSUs: ≥${minW}W.`);
      ensureSelection(psuSelect);
      filterPSUs(true);
    });
  });
  psuClear?.addEventListener("click", ()=> clearFilter("psuFilters", psuSelect));

  // Motherboard socket filters (was present in template but missing JS binding)
  document.querySelectorAll("#moboSocketFilters button[data-socket]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const socket = btn.dataset.socket;
      [...moboSelect.options].forEach(opt => { opt.hidden = (opt.dataset.socket !== socket); });
      activate("moboSocketFilters", btn);
      showTooltip("moboMessage", `Filtered motherboards: ${socket.toUpperCase()}.`);
      ensureSelection(moboSelect);
      // re-run dependent filters
      filterRamByMobo(true);
      filterCases(true);
      filterStorage(true);
      // also re-evaluate cpu <> mobo compatibility so highlights/tooltips stay accurate
      filterMobosByCpu(true);
    });
  });
  moboSocketClear?.addEventListener("click", ()=> { clearFilter("moboSocketFilters", moboSelect); filterMobosByCpu(true); });

  // Case form-factor filters (was present in template but missing JS binding)
  document.querySelectorAll("#caseFormFilters button[data-formfactor]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const ff = btn.dataset.formfactor.toLowerCase();
      [...caseSelect.options].forEach(opt => {
        const caseFF = (opt.dataset.formfactor || "").toLowerCase();
        opt.hidden = !caseFF.includes(ff);
      });
      activate("caseFormFilters", btn);
      showTooltip("caseMessage", `Filtered cases: ${ff.toUpperCase()}.`);
      ensureSelection(caseSelect);
      filterCases(true);
    });
  });
  caseFormClear?.addEventListener("click", ()=> clearFilter("caseFormFilters", caseSelect));

  document.querySelectorAll("#coolerFilters button[data-throughput]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const minT = parseInt(btn.dataset.throughput,10);
      [...coolerSelect.options].forEach(opt => {
        const th = parseInt(opt.dataset.throughput || "0",10);
        opt.hidden = th < minT;
      });
      activate("coolerFilters", btn);
      showTooltip("coolerMessage", `Filtered Coolers: ≥${minT}W.`);
      ensureSelection(coolerSelect);
      filterCoolers(true);
    });
  });
  coolerClear?.addEventListener("click", ()=> clearFilter("coolerFilters", coolerSelect));

  // Initial pass: run filters but only show tooltips if current selection is invalid
  filterMobosByCpu(true);
  filterMobosByRam(true);
  filterRamByMobo(true);
  filterCases(true);
  filterStorage(true);
  filterPSUs(true);
  filterCoolers(true);

  // Change events to re-check compatibility and tooltips
  cpuSelect.addEventListener("change", ()=>{ filterMobosByCpu(true); filterPSUs(true); filterCoolers(true); });
  gpuSelect.addEventListener("change", ()=>{ filterPSUs(true); });
  ramSelect.addEventListener("change", ()=>{ filterMobosByRam(true); filterRamByMobo(true); });
  moboSelect.addEventListener("change", ()=>{ filterRamByMobo(true); filterCases(true); filterStorage(true); filterMobosByCpu(true); });

});
</script>

<script>
  // Paste the consolidated script we built here
</script>
{% endblock %}
